import jsxParser from 'acorn-jsx';
import { fromJs } from 'esast-util-from-js';
import { jsx, toJs } from 'estree-util-to-js';
import { remark } from 'remark';
import { removePosition } from 'unist-util-remove-position';
import { visit } from 'unist-util-visit';
import { coreRemarkMdxPlugins } from '../remark.js';
import { isExportNode } from '../utils.js';
import { mdxMdToHtml } from './mdxMdToHtml/index.js';
import { nodeIncludesExport } from './nodeIncludesExport.js';
import { removeOuterParagraph } from './removeOuterParagraph.js';
/**
 * Specifically targets the content of an export statement and converts simple md syntax to html
 * for example:
 * export const myString = `# Hello World`
 * will be converted to:
 * export const myString = `<h1>Hello World</h1>`
 */
export const mdToHtmlInExports = (content) => {
    try {
        const convertedContent = remark()
            .use(coreRemarkMdxPlugins)
            .use(remarkMdxMdInExportsToHtml)
            .processSync(content);
        return String(convertedContent);
    }
    catch (err) {
        console.log(err);
        return content;
    }
};
const remarkMdxMdInExportsToHtml = () => (tree) => {
    visit(tree, nodeIncludesExport, (node) => {
        var _a, _b;
        if (!nodeIncludesExport(node))
            return;
        const body = node.data.estree.body;
        for (const bodyChild of body) {
            if (isExportNode(bodyChild)) {
                if (bodyChild.type === 'ExportAllDeclaration')
                    continue;
                if (((_a = bodyChild.declaration) === null || _a === void 0 ? void 0 : _a.type) !== 'VariableDeclaration')
                    continue;
                const declaration = bodyChild.declaration.declarations[0];
                if (declaration == undefined)
                    continue;
                const init = declaration.init;
                if (init == null)
                    continue;
                if (init.type === 'Literal' && init.value != undefined) {
                    // string export
                    try {
                        if (init.raw == undefined || !isString(init.raw))
                            continue;
                        const newValue = removeOuterParagraph(mdxMdToHtml(String(init.value)));
                        init.value = newValue;
                        init.raw = '`' + newValue + '`';
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
                else if (init.type === 'ArrowFunctionExpression') {
                    // component export
                    // TODO: Make this more robust by going deeper into the tree and only converting the first text node to md
                    const arrowFunctionBody = toJs({
                        type: 'Program',
                        sourceType: 'module',
                        body: [init.body],
                    }, { handlers: jsx }).value;
                    const mdRemovedBody = mdxMdToHtml(arrowFunctionBody);
                    const mdRemovedBodyTree = fromJs(mdRemovedBody, { plugins: [jsxParser()] });
                    if ((_b = mdRemovedBodyTree.body[0]) === null || _b === void 0 ? void 0 : _b.expression) {
                        init.body = mdRemovedBodyTree.body[0].expression;
                    }
                }
                removePosition(node);
                const newValue = toJs(node.data.estree, { handlers: jsx }).value;
                node.value = newValue;
            }
        }
    });
};
const isString = (str) => {
    const firstChar = str.charAt(0);
    const lastChar = str.charAt(str.length - 1);
    if (firstChar !== lastChar)
        return false;
    if (["'", '"', '`'].includes(firstChar))
        return true;
};
