import { jsx, toJs } from 'estree-util-to-js';
import { remark } from 'remark';
import { remove } from 'unist-util-remove';
import { removePosition } from 'unist-util-remove-position';
import { MdxImportSpecifier } from '../../types/mdx/index.js';
import { coreRemarkMdxPlugins } from '../remark.js';
import { isMdxJsEsm, estreeIsProgram, isImportDeclaration } from '../utils.js';
/**
  An import like "import {Chart} from './chart.mdx'" looks like this in the AST:
  {
    type: 'mdxjsEsm',
    data: {
      estree: {
        type: 'Program',
        sourceType: 'module',
        body: [{
          type: 'ImportDeclaration',
          source: {
            value: './chart.mdx'
          },
          specifiers: [{
            type: 'ImportSpecifier',
            local: {
              type: 'Identifier',
              name: 'Chart'
            }
          }]
        }]
      }
    }
  }
 * this function takes in a string finds and removes imports in it (by detecting the node with the above characteristics)
 * @param content mdx file content
 * @returns importPaths - an array of the imports
 * content - the mdx file content with stripped imports
 */
export const findAndRemoveImports = (content) => {
    const imports = [];
    const strippedContent = remark()
        .use(coreRemarkMdxPlugins)
        .use(() => (tree) => {
        remove(tree, (node) => {
            if (isMdxJsEsm(node) && estreeIsProgram(node)) {
                const newBody = [];
                for (const bodyChild of node.data.estree.body) {
                    if (isImportDeclaration(bodyChild) && typeof bodyChild.source.value === 'string') {
                        const importDeclaration = {
                            source: bodyChild.source.value,
                            specifiers: bodyChild.specifiers.map((specifier) => {
                                const isRenamedImportSpecifier = specifier.type === 'ImportSpecifier' &&
                                    specifier.imported.name != specifier.local.name;
                                return Object.assign({ type: isRenamedImportSpecifier
                                        ? MdxImportSpecifier.RenamedImportSpecifier
                                        : specifier.type, name: isRenamedImportSpecifier ? specifier.imported.name : specifier.local.name }, (isRenamedImportSpecifier && {
                                    renamedName: specifier.local.name,
                                }));
                            }),
                        };
                        imports.push(importDeclaration);
                    }
                    else {
                        newBody.push(bodyChild);
                    }
                }
                if (newBody.length != 0) {
                    node.data.estree.body = newBody;
                    if (node.value) {
                        delete node.value;
                    }
                    removePosition(node);
                    const newValue = toJs(node.data.estree, { handlers: jsx }).value;
                    node.value = newValue;
                    return false;
                }
                return true;
            }
        });
        return tree;
    })
        .processSync(content);
    return { imports, content: String(strippedContent) };
};
